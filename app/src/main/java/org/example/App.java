/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.math.BigDecimal;
import java.math.RoundingMode;

import net.objecthunter.exp4j.Expression;
import net.objecthunter.exp4j.ExpressionBuilder;

public class App {
    public static void main(String[] args) {
        Expression expr = new ExpressionBuilder("x^3 - x - 1")
                            .variable("x")
                            .build();
        System.out.println(secant(expr, 1.2, 1.4));
    }

    public static double numericalDerivative(Expression expression, double x) {
        double h = 1e-5;  // Small change in x (step size)

        // Create the expression with the variable 'x'
        

        // Evaluate the function at x + h
        expression.setVariable("x", x + h);
        double f1 = expression.evaluate();

        // Evaluate the function at x - h
        expression.setVariable("x", x - h);
        double f2 = expression.evaluate();

        // Approximate the derivative using the central difference formula
        return Math.round((f1 - f2) / (2 * h));
    }

    public static double newtonRaphson(Expression expression, double x){
        //base case:
        double xd = numericalDerivative(expression, x);
        if (new BigDecimal(xd).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0) {
            System.out.println("Derivative is zero. Cannot proceed.");
            return x;  
        }

        double nextX = x - (expression.setVariable("x", x).evaluate() / xd);

        if (Math.abs(nextX - x) <= 1e-4){
            return nextX;
        } else {
            return newtonRaphson(expression, nextX);
        } 
    }

    public static double secant(Expression expression, double x0, double x1){
        //base case:

        double nextX = x1 - (expression.setVariable("x", x1).evaluate() * ((x1 - x0) / (expression.setVariable("x", x1).evaluate() - expression.setVariable("x", x0).evaluate())));

        if(Math.abs(nextX - x1) <= 1e-4){
            return nextX;
        } else {
            return secant(expression, x1, nextX);
        }
    }


    
}
