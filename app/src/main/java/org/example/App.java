/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;



import net.objecthunter.exp4j.Expression;
import net.objecthunter.exp4j.ExpressionBuilder;

public class App {
    public static void main(String[] args) {
        Expression expression = new ExpressionBuilder("x^3 + 4x^2 - 10")
                                    .variable("x")
                                    .build();

        List<Tuple<Double, Double>> xn = new ArrayList<>();
        double xL = 1;
        double xR = 2;
        xn.add(new Tuple<Double,Double>(xL, xR));
        System.out.println(bisection(expression, xL, xR, xn));
                                
        
    }

    public static double numericalDerivative(Expression expression, double x) {
        double h = 1e-5;  // Small change in x (step size)

        // Create the expression with the variable 'x'
        

        // Evaluate the function at x + h
        expression.setVariable("x", x + h);
        double f1 = expression.evaluate();

        // Evaluate the function at x - h
        expression.setVariable("x", x - h);
        double f2 = expression.evaluate();

        // Approximate the derivative using the central difference formula
        return Math.round((f1 - f2) / (2 * h));
    }

    public static List<Double> newtonRaphson(Expression expression, double x, List<Double> xn){
        //base case:
        double xd = numericalDerivative(expression, x);
        if (new BigDecimal(xd).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0) {
            System.out.println("Derivative is zero. Cannot proceed.");
            return xn;
        }

        double nextX = x - (expression.setVariable("x", x).evaluate() / xd);
        xn.add(nextX);
        if (Math.abs(nextX - x) <= 1e-4){
            return xn;
        } else {
            return newtonRaphson(expression, nextX, xn);
        } 
    }

    public static List<Double> secant(Expression expression, double x0, double x1, List<Double> xn){
        //base case:

        double nextX = x1 - (expression.setVariable("x", x1).evaluate() * ((x1 - x0) / (expression.setVariable("x", x1).evaluate() - expression.setVariable("x", x0).evaluate())));
        xn.add(nextX);

        if(Math.abs(nextX - x1) <= 1e-4){
            return xn;
        } else {
            return secant(expression, x1, nextX, xn);
        }
    }

    public static List<Tuple<Double, Double>> bisection(Expression expression, double xL, double xR, List<Tuple<Double, Double>> xn){
        //base case:
        double xM = (xL + xR) / 2;
        if(expression.setVariable("x", xL).evaluate() * expression.setVariable("x", xR).evaluate()> 0){
            System.out.println("xL and xR should have opposite signs");
            return xn;
        }
        
        double fxM = expression.setVariable("x", xM).evaluate();

        if(new BigDecimal(fxM).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0){
            return xn;
        } else if (expression.setVariable("x", xL).evaluate() * fxM < 0){
            xn.add(new Tuple<Double, Double>(xL, xM));
            return bisection(expression, xL, xM, xn);
        } else {
            xn.add(new Tuple<Double, Double>(xM, xL));
            return bisection(expression, xM, xR, xn);
        }

    }

    public static double falsePosition(Expression expression, double xL, double xR){
        if(expression.setVariable("x", xL).evaluate() * expression.setVariable("x", xR).evaluate()> 0){
            System.out.println("xL and xR should have opposite signs");
            return xL;
        }
        double nextX = xL + (((xR-xL) * (-1 * expression.setVariable("x", xL).evaluate())) / (expression.setVariable("x", xR).evaluate() - expression.setVariable("x", xL).evaluate()));
        if(new BigDecimal(expression.setVariable("x", nextX).evaluate()).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0){
            return nextX;
        } else if (expression.setVariable("x", xL).evaluate() * expression.setVariable("x", nextX).evaluate() < 0){
            return falsePosition(expression, xL, nextX);
        } else {
            return falsePosition(expression, nextX, xR);
        }
    }
    //only works for when matrix a and b is a one dimensional array
    public static int[][] matrixMultiplication(int[] a, int[] b){
        int[][] ab = new int[a.length][b.length];
        for(int i = 0; i < a.length; i++){
            for(int j = 0; j < b.length; j++){
                ab[i][j] = a[i] * b[j];
            }
        }
        return ab;
    }

    //can only solve 3x3 matrix (x, y, z)
    //need muna iparse into matrix
    public static double[] cramer(double[][] matrix){
        
        
        double d = matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                    + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
        double dx = matrix[0][3] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][3] * matrix[2][2] - matrix[1][2] * matrix[2][3])
                    + matrix[0][2] * (matrix[1][3] * matrix[2][1] - matrix[1][1] * matrix[2][3]);
        double dy = matrix[0][0] * (matrix[1][3] * matrix[2][2] - matrix[1][2] * matrix[2][3])
                    - matrix[0][3] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                    + matrix[0][2] * (matrix[1][0] * matrix[2][3] - matrix[1][3] * matrix[2][0]);
        double dz = matrix[0][0] * (matrix[1][1] * matrix[2][3] - matrix[1][3] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][0] * matrix[2][3] - matrix[1][3] * matrix[2][0])
                    + matrix[0][3] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);

        dx = dx / d;
        dy = dy / d;
        dz = dz / d;
        double[] answer = {dx, dy, dz};
        return answer;
    }

    //dapat iparse muna as matrix
    public static double[] guassianElimination(double[][] matrix){
        
        
        for(int i = 0; i < matrix.length; i++){

            for(int j = i + 1; j < matrix.length; j++){
                if(Math.abs(matrix[j][i]) > Math.abs(matrix[i][i])){
                    double[] temp = matrix[i];
                    matrix[i] = matrix[j];
                    matrix[j] = temp;
                }
            }

            

            for (int j = i + 1; j < matrix.length; j++) {
                double factor = matrix[j][i] / matrix[i][i];
                for (int k = i; k <= matrix.length; k++) {
                    matrix[j][k] -= factor * matrix[i][k];
                }
            }
            
        }



        // Back Substitution
        double[] solution = new double[matrix.length];
        for (int i = matrix.length - 1; i >= 0; i--) {
            double sum = 0;
            for (int j = i + 1; j < matrix.length; j++) {
                sum += matrix[i][j] * solution[j];
            }
            solution[i] = (matrix[i][matrix.length] - sum) / matrix[i][i];
        }

        return solution;
    }

    //iparse muna as matrix
    public static double[] jacobi(double[][] matrix){
       
        
        //still cant wrap my head around this shit man
        for (int i = 0; i < matrix.length; i++) {
            int maxRow = i;
            for (int j = i + 1; j < matrix.length; j++) {
                if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
                    maxRow = j;
                }
            }

            // Swap if a more dominant row is found
            if (maxRow != i) {
                double[] temp = matrix[i];
                matrix[i] = matrix[maxRow];
                matrix[maxRow] = temp;
            }
        }
        
        //insert initial guess
        double[] initialGuess = {0, 0, 0};
        
        
        return jacobiEvaluate(matrix, initialGuess);

        

    }

    public static double[] jacobiEvaluate(double[][] matrix, double[] guess){
        double nextGuess[] = new double[3];
        nextGuess[0] = (-matrix[0][1] * guess[1] + -matrix[0][2] * guess[2] + matrix[0][3]) / matrix[0][0];
        nextGuess[1] = (-matrix[1][0] * guess[0] + -matrix[1][2] * guess[2] + matrix[1][3]) / matrix[1][1];
        nextGuess[2] = (-matrix[2][0] * guess[0] + -matrix[2][1] * guess[1] + matrix[2][3]) / matrix[2][2];
        System.out.println(Arrays.toString(nextGuess));
        if(Math.abs(nextGuess[0] - guess[0]) < 1e-3 && Math.abs(nextGuess[1] - guess[1]) < 1e-3 && Math.abs(nextGuess[2] - guess[2]) < 1e-3){
            return nextGuess;
        } else {
            
            return jacobiEvaluate(matrix, nextGuess);
        }
    }

    public static double[] gaussSeidel(double[][] matrix){
       
        
        //still cant wrap my head around this shit man
        for (int i = 0; i < matrix.length; i++) {
            int maxRow = i;
            for (int j = i + 1; j < matrix.length; j++) {
                if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
                    maxRow = j;
                }
            }

            // Swap if a more dominant row is found
            if (maxRow != i) {
                double[] temp = matrix[i];
                matrix[i] = matrix[maxRow];
                matrix[maxRow] = temp;
            }
        }
        
        //insert initial guess
        double[] initialGuess = {0, 0, 0};
        
        
        return gaussSeidelEvaluate(matrix, initialGuess);

        

    }

    public static double[] gaussSeidelEvaluate(double[][] matrix, double[] guess){
        double nextGuess[] = new double[3];
        nextGuess[0] = (-matrix[0][1] * guess[1] + -matrix[0][2] * guess[2] + matrix[0][3]) / matrix[0][0];
        nextGuess[1] = (-matrix[1][0] * nextGuess[0] + -matrix[1][2] * guess[2] + matrix[1][3]) / matrix[1][1];
        nextGuess[2] = (-matrix[2][0] * nextGuess[0] + -matrix[2][1] * nextGuess[1] + matrix[2][3]) / matrix[2][2];
        System.out.println(Arrays.toString(nextGuess));
        if(Math.abs(nextGuess[0] - guess[0]) < 1e-3 && Math.abs(nextGuess[1] - guess[1]) < 1e-3 && Math.abs(nextGuess[2] - guess[2]) < 1e-3){
            return nextGuess;
        } else {
            
            return gaussSeidelEvaluate(matrix, nextGuess);
        }
    }

    

    
    
    public static double[][] parseEquation(String[] equations){
        double[][] matrix = new double[3][4];
        for(int i = 0; i < equations.length; i++){
            String[] parsedEquation = new String[2];
            equations[i].indexOf('=');
            parsedEquation[0] = equations[i].substring(0, equations[i].indexOf('=')).trim();
            parsedEquation[1] = equations[i].substring(equations[i].indexOf('=') + 1, equations[i].length()).trim();
            
            matrix[i][0] = new ExpressionBuilder(parsedEquation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 1)
                                .setVariable("y", 0)
                                .setVariable("z", 0)
                                .evaluate();
            matrix[i][1] = new ExpressionBuilder(parsedEquation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 0)
                                .setVariable("y", 1)
                                .setVariable("z", 0)
                                .evaluate();
            matrix[i][2] = new ExpressionBuilder(parsedEquation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 0)
                                .setVariable("y", 0)
                                .setVariable("z", 1)
                                .evaluate();
            matrix[i][3] = Double.parseDouble(parsedEquation[1]);                  
        }
        return matrix;

    }
    
}
