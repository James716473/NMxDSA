/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;

import net.objecthunter.exp4j.Expression;
import net.objecthunter.exp4j.ExpressionBuilder;

public class App {
    public static void main(String[] args) {
        String[] equations = {
            "2x + y - z = 1",
            "3x - y + z = 4",
            "2x + 3y + z = 3"
        };
        System.out.println(cramer(equations));
    }

    public static double numericalDerivative(Expression expression, double x) {
        double h = 1e-5;  // Small change in x (step size)

        // Create the expression with the variable 'x'
        

        // Evaluate the function at x + h
        expression.setVariable("x", x + h);
        double f1 = expression.evaluate();

        // Evaluate the function at x - h
        expression.setVariable("x", x - h);
        double f2 = expression.evaluate();

        // Approximate the derivative using the central difference formula
        return Math.round((f1 - f2) / (2 * h));
    }

    public static double newtonRaphson(Expression expression, double x){
        //base case:
        double xd = numericalDerivative(expression, x);
        if (new BigDecimal(xd).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0) {
            System.out.println("Derivative is zero. Cannot proceed.");
            return x;  
        }

        double nextX = x - (expression.setVariable("x", x).evaluate() / xd);

        if (Math.abs(nextX - x) <= 1e-4){
            return nextX;
        } else {
            return newtonRaphson(expression, nextX);
        } 
    }

    public static double secant(Expression expression, double x0, double x1){
        //base case:

        double nextX = x1 - (expression.setVariable("x", x1).evaluate() * ((x1 - x0) / (expression.setVariable("x", x1).evaluate() - expression.setVariable("x", x0).evaluate())));

        if(Math.abs(nextX - x1) <= 1e-4){
            return nextX;
        } else {
            return secant(expression, x1, nextX);
        }
    }

    public static double bisection(Expression expression, double xL, double xR){
        //base case:
        double xM = (xL + xR) / 2;
        if(expression.setVariable("x", xL).evaluate() * expression.setVariable("x", xR).evaluate()> 0){
            System.out.println("xL and xR should have opposite signs");
            return xM;
        }
        
        double fxM = expression.setVariable("x", xM).evaluate();

        if(new BigDecimal(fxM).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0){
            return xM;
        } else if (expression.setVariable("x", xL).evaluate() * fxM < 0){
            return bisection(expression, xL, xM);
        } else {
            return bisection(expression, xM, xR);
        }

    }

    public static double falsePosition(Expression expression, double xL, double xR){
        if(expression.setVariable("x", xL).evaluate() * expression.setVariable("x", xR).evaluate()> 0){
            System.out.println("xL and xR should have opposite signs");
            return xL;
        }
        double nextX = xL + (((xR-xL) * (-1 * expression.setVariable("x", xL).evaluate())) / (expression.setVariable("x", xR).evaluate() - expression.setVariable("x", xL).evaluate()));
        if(new BigDecimal(expression.setVariable("x", nextX).evaluate()).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0){
            return nextX;
        } else if (expression.setVariable("x", xL).evaluate() * expression.setVariable("x", nextX).evaluate() < 0){
            return falsePosition(expression, xL, nextX);
        } else {
            return falsePosition(expression, nextX, xR);
        }
    }
    //only works for when matrix a and b is a one dimensional array
    public static int[][] matrixMultiplication(int[] a, int[] b){
        int[][] ab = new int[a.length][b.length];
        for(int i = 0; i < a.length; i++){
            for(int j = 0; j < b.length; j++){
                ab[i][j] = a[i] * b[j];
            }
        }
        return ab;
    }

    //can only solve 3x3 matrix (x, y, z)
    public static double cramer(String[] equations){
        double[][] matrix = new double[3][4];
        for(int i = 0; i < matrix.length; i++){
            String[] equation = parseEquation(equations[i]);
            matrix[i][0] = new ExpressionBuilder(equation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 1)
                                .setVariable("y", 0)
                                .setVariable("z", 0)
                                .evaluate();
            matrix[i][1] = new ExpressionBuilder(equation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 0)
                                .setVariable("y", 1)
                                .setVariable("z", 0)
                                .evaluate();
            matrix[i][2] = new ExpressionBuilder(equation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 0)
                                .setVariable("y", 0)
                                .setVariable("z", 1)
                                .evaluate();
            matrix[i][3] = Double.parseDouble(equation[1]);                  
        }
        double d = matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                    + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);

        return d;
    }

    public static String[] parseEquation(String equation){
        String[] parsedEquation = new String[2];
        equation.indexOf('=');
        parsedEquation[0] = equation.substring(0, equation.indexOf('=')).trim();
        parsedEquation[1] = equation.substring(equation.indexOf('=') + 1, equation.length()).trim();
        return parsedEquation;

    }
    
}
