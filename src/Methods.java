/*
 * This source file was generated by the Gradle 'init' task
 */

import com.formdev.flatlaf.FlatLightLaf;
import net.miginfocom.swing.MigLayout;
import javax.swing.*;
import java.awt.*;
import javax.swing.plaf.basic.BasicButtonUI;
import javax.swing.border.Border;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import net.objecthunter.exp4j.Expression;
import net.objecthunter.exp4j.ExpressionBuilder;

public class Methods {

    private int maxIteration;
    private BigDecimal tolerance;

    public Methods(int maxIteration) {
        this.maxIteration = maxIteration;
        this.tolerance = new BigDecimal(1e-3);
    }

    public void setMaxIteration(int maxIteration) {
        this.maxIteration = maxIteration;
    }

    public void setTolerance(BigDecimal tolerance) {
        this.tolerance = tolerance;
    }

    public double numericalDerivative(Expression expression, double x) {
        double h = 1e-5;  // Small change in x (step size)

        // Create the expression with the variable 'x'
        

        // Evaluate the function at x + h
        expression.setVariable("x", x + h);
        double f1 = expression.evaluate();

        // Evaluate the function at x - h
        expression.setVariable("x", x - h);
        double f2 = expression.evaluate();

        // Approximate the derivative using the central difference formula
        return Math.round((f1 - f2) / (2 * h));
    }

    //need a error handling where |g'(x)| < 1
    public List<Double> fixedPoint(Expression expression, double x, List<Double> xn){
        if(!(Math.abs(numericalDerivative(expression, x)) <= 1) && xn.size() == 0){
            System.out.println("|g'(x)| >= 1. Cannot proceed.");
            return xn;
        }
        if(xn.size() == 0){ // para masama yung initial guess
            xn.add(x);
        }
        if(xn.size() == maxIteration + 1){ // para masama yung initial guess
            System.out.println("Max iterations reached. Cannot proceed.");
            return xn;
        }
        double nextX = expression.setVariable("x", x).evaluate();
        
        if(Math.abs(nextX - x) <= tolerance.doubleValue()){
            nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue(); 
            xn.add(nextX);
            return xn;
        } else {
            nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue(); 
            xn.add(nextX); 
            return fixedPoint(expression, nextX, xn);
        }
    }

    public List<Double> newtonRaphson(Expression expression, double x, List<Double> xn){
        if(xn.size() == 0){ // para masama yung initial guess
            xn.add(x);
        }
        if(xn.size() == maxIteration + 1){ // para masama yung initial guess
            System.out.println("Max iterations reached. Cannot proceed.");
            return xn;
        }
        double xd = numericalDerivative(expression, x);
        if (new BigDecimal(xd).setScale(4, RoundingMode.HALF_UP).compareTo(BigDecimal.ZERO) == 0) {
            System.out.println("Derivative is zero. Cannot proceed.");
            return xn;
        }

        double nextX = x - (expression.setVariable("x", x).evaluate() / xd);
        
        if(Math.abs(nextX - x) <= tolerance.doubleValue()){
            nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();// ginagawa lang neto is niroroundoff ung x base dun sa tolerance
            xn.add(nextX);
            return xn;
        } else {
            nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();// ginagawa lang neto is niroroundoff ung x base dun sa tolerance
            xn.add(nextX); 
            return newtonRaphson(expression, nextX, xn);
        }
    }

    public List<Double> secant(Expression expression, double x0, double x1, List<Double> xn){
        if(xn.size() == 0){ // para masama yung initial guess
            xn.add(x0);
            xn.add(x1);
        }
        if(xn.size() == maxIteration + 2){ // para masama yung initial guess
            System.out.println("Max iterations reached. Cannot proceed.");
            return xn;
        }
        
        double nextX = x1 - (expression.setVariable("x", x1).evaluate() * ((x1 - x0) / (expression.setVariable("x", x1).evaluate() - expression.setVariable("x", x0).evaluate())));
        
        
        if(Math.abs(nextX - x1) <= tolerance.doubleValue()){
            nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            xn.add(nextX);
            return xn;
        } else {
            nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            xn.add(nextX); 
            return secant(expression, x1, nextX, xn);
        }
    }

    public List<Double[]> bisection(Expression expression, double xL, double xR, List<Double[]> xn){
        //base case:
       
        if(xn.size() == maxIteration + 1){
            System.out.println("Max iterations reached. Cannot proceed.");
            return xn;
        }
        
        double xM = (xL + xR) / 2;
        if(expression.setVariable("x", xL).evaluate() * expression.setVariable("x", xR).evaluate()> 0 && xn.size() == 0){
            System.out.println("xL and xR should have opposite signs");
            System.out.println(expression.setVariable("x", xL).evaluate() * expression.setVariable("x", xR).evaluate());
            return xn;
        }
        
        
        double fxM = expression.setVariable("x", xM).evaluate();
        
        if(xn.size() == 0){
            fxM = new BigDecimal(fxM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            Double[] x = {xL, xR, fxM, xM};
            xn.add(x);
        }
        
        if(Math.abs(fxM) <= tolerance.doubleValue() || Math.abs(xR - xL) <= tolerance.doubleValue()){
            xM = new BigDecimal(xM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            fxM = new BigDecimal(fxM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            Double[] x = {xM, xM, fxM, xM};
            xn.add(x);
            return xn;
        } else if (expression.setVariable("x", xL).evaluate() * fxM < 0){
            xM = new BigDecimal(xM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            fxM = new BigDecimal(fxM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            Double[] x = {xL, xM, fxM, xM};
            xn.add(x);
            return bisection(expression, xL, xM, xn);
        } else {
            xM = new BigDecimal(xM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            fxM = new BigDecimal(fxM).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            Double[] x = {xM, xR, fxM, xM};
            xn.add(x);
            return bisection(expression, xM, xR, xn);
        }
        
        

    }

    public List<Double[]> falsePosition(Expression expression, double xL, double xR, List<Double[]> xn) {
        if (xn.size() == maxIteration + 1) {
            System.out.println("Max iterations reached. Cannot proceed.");
            return xn;
        }
    
        double fXL = expression.setVariable("x", xL).evaluate();
        double fXR = expression.setVariable("x", xR).evaluate();
    
        if (fXL * fXR > 0) {
            System.out.println("xL and xR should have opposite signs");
            return xn;
        }
    
        // False Position Formula
        double nextX = xL - fXL * (xR - xL) / (fXR - fXL);
        double fNextX = expression.setVariable("x", nextX).evaluate();
    
        // Round to tolerance
        nextX = new BigDecimal(nextX).divide(tolerance, 0, RoundingMode.HALF_UP)
                                     .multiply(tolerance).doubleValue();
        fNextX = new BigDecimal(fNextX).divide(tolerance, 0, RoundingMode.HALF_UP)
                                       .multiply(tolerance).doubleValue();
    
        // Save iteration data
        Double[] row = {xL, xR, fNextX, nextX};
        xn.add(row);
    
        // Check for convergence
        if (Math.abs(fNextX) <= tolerance.doubleValue() ||
            Math.abs(nextX - xL) <= tolerance.doubleValue() ||
            Math.abs(nextX - xR) <= tolerance.doubleValue()) {
            return xn;
        }
    
        // Update interval based on sign and recurse
        if (fXL * fNextX < 0) {
            // Root is between xL and nextX
            return falsePosition(expression, xL, nextX, xn);
        } else {
            // Root is between nextX and xR
            return falsePosition(expression, nextX, xR, xn);
        }
    }
    
    //only works for when matrix a and b is a one dimensional array
    public int[][] matrixMultiplication(int[] a, int[] b){
        int[][] ab = new int[a.length][b.length];
        for(int i = 0; i < a.length; i++){
            for(int j = 0; j < b.length; j++){
                ab[i][j] = a[i] * b[j];
            }
        }
        return ab;
    }

    public int[][] matrixMultiplication(int[][] a, int[][] b) {
        int m = a.length;         // rows in A
        int n = a[0].length;      // cols in A (must equal rows in B)
        int p = b[0].length;      // cols in B
    
        // Create result matrix
        int[][] result = new int[m][p];
    
        // Perform multiplication
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < p; j++) {
                result[i][j] = 0;
                for (int k = 0; k < n; k++) {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }
    
        return result;
    }
    

    //can only solve 3x3 matrix (x, y, z)
    //need muna iparse into matrix
    public double[] cramer(double[][] matrix, JTextArea solution){
        
        solution.setText("Solving the system of equations using Cramer's Rule...\n");
        double d = matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                    + matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
        double dx = matrix[0][3] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][3] * matrix[2][2] - matrix[1][2] * matrix[2][3])
                    + matrix[0][2] * (matrix[1][3] * matrix[2][1] - matrix[1][1] * matrix[2][3]);
        double dy = matrix[0][0] * (matrix[1][3] * matrix[2][2] - matrix[1][2] * matrix[2][3])
                    - matrix[0][3] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])
                    + matrix[0][2] * (matrix[1][0] * matrix[2][3] - matrix[1][3] * matrix[2][0]);
        double dz = matrix[0][0] * (matrix[1][1] * matrix[2][3] - matrix[1][3] * matrix[2][1])
                    - matrix[0][1] * (matrix[1][0] * matrix[2][3] - matrix[1][3] * matrix[2][0])
                    + matrix[0][3] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);
        String dStr = "d = " + matrix[0][0] + " * (" + matrix[1][1] + " * " + matrix[2][2] + " - " + matrix[1][2] + " * " + matrix[2][1] + ")"
                    + " - " + matrix[0][1] + " * (" + matrix[1][0] + " * " + matrix[2][2] + " - " + matrix[1][2] + " * " + matrix[2][0] + ")"
                    + " + " + matrix[0][2] + " * (" + matrix[1][0] + " * " + matrix[2][1] + " - " + matrix[1][1] + " * " + matrix[2][0] + ")";
        
        String dxStr = "dx = " + matrix[0][3] + " * (" + matrix[1][1] + " * " + matrix[2][2] + " - " + matrix[1][2] + " * " + matrix[2][1] + ")"
                     + " - " + matrix[0][1] + " * (" + matrix[1][3] + " * " + matrix[2][2] + " - " + matrix[1][2] + " * " + matrix[2][3] + ")"
                     + " + " + matrix[0][2] + " * (" + matrix[1][3] + " * " + matrix[2][1] + " - " + matrix[1][1] + " * " + matrix[2][3] + ")";
        
        String dyStr = "dy = " + matrix[0][0] + " * (" + matrix[1][3] + " * " + matrix[2][2] + " - " + matrix[1][2] + " * " + matrix[2][3] + ")"
                     + " - " + matrix[0][3] + " * (" + matrix[1][0] + " * " + matrix[2][2] + " - " + matrix[1][2] + " * " + matrix[2][0] + ")"
                     + " + " + matrix[0][2] + " * (" + matrix[1][0] + " * " + matrix[2][3] + " - " + matrix[1][3] + " * " + matrix[2][0] + ")";
        
        String dzStr = "dz = " + matrix[0][0] + " * (" + matrix[1][1] + " * " + matrix[2][3] + " - " + matrix[1][3] + " * " + matrix[2][1] + ")"
                     + " - " + matrix[0][1] + " * (" + matrix[1][0] + " * " + matrix[2][3] + " - " + matrix[1][3] + " * " + matrix[2][0] + ")"
                     + " + " + matrix[0][3] + " * (" + matrix[1][0] + " * " + matrix[2][1] + " - " + matrix[1][1] + " * " + matrix[2][0] + ")";
        solution.append(dStr + "\n");
        solution.append("d = " + d + "\n");
        solution.append(dxStr + "\n");
        solution.append("dx = " + dx + "\n");
        solution.append(dyStr + "\n");
        solution.append("dy = " + dy + "\n");
        solution.append(dzStr + "\n");
        solution.append("dz = " + dz + "\n");
        solution.append("x = " + dx + " / " + d + "\n");
        solution.append("y = " + dy + " / " + d + "\n");
        solution.append("z = " + dz + " / " + d + "\n");
        
        dx = dx / d;
        dy = dy / d;
        dz = dz / d;
        dx = new BigDecimal(dx).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        dy = new BigDecimal(dy).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        dz = new BigDecimal(dz).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        double[] answer = {dx, dy, dz};
        return answer;
    }

    //dapat iparse muna as matrix
    public double[] gaussianElimination(double[][] matrix, JTextArea solution){
        
        
        for(int i = 0; i < matrix.length; i++){

            for(int j = i + 1; j < matrix.length; j++){
                if(Math.abs(matrix[j][i]) > Math.abs(matrix[i][i])){
                    double[] temp = matrix[i];
                    matrix[i] = matrix[j];
                    matrix[j] = temp;
                }
            }

            

            for (int j = i + 1; j < matrix.length; j++) {
                double factor = matrix[j][i] / matrix[i][i];
                for (int k = i; k <= matrix.length; k++) {
                    matrix[j][k] -= factor * matrix[i][k];
                    
                }
            }
            
        }
        solution.append("Row Echelon Form: \n");
        for(int i = 0; i < matrix.length; i++){
            for(int j = 0; j < matrix[i].length; j++){
                matrix[i][j] = new BigDecimal(matrix[i][j]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
                solution.append(matrix[i][j] + " ");
            }
            solution.append("\n");
        }

        solution.append("\n");





        // Back Substitution
        double[] solutions = new double[matrix.length];
        for (int i = matrix.length - 1; i >= 0; i--) {
            double sum = 0;
            for (int j = i + 1; j < matrix.length; j++) {
                sum += matrix[i][j] * solutions[j];
            }
            solutions[i] = new BigDecimal((matrix[i][matrix.length] - sum) / matrix[i][i]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        }

        return solutions;
    }

    //iparse muna as matrix
    public List<Double[]> jacobi(double[][] matrix, List<Double[]> xyz){
        
        
        //still cant wrap my head around this shit man
        for (int i = 0; i < matrix.length; i++) {
            int maxRow = i;
            for (int j = i + 1; j < matrix.length; j++) {
                if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
                    maxRow = j;
                }
            }

            // Swap if a more dominant row is found
            if (maxRow != i) {
                double[] temp = matrix[i];
                matrix[i] = matrix[maxRow];
                matrix[maxRow] = temp;
            }
        }
        
        //insert initial guess
        Double[] guess = {0.0, 0.0 , 0.0};
        
        
        return jacobiEvaluate(matrix, guess, xyz);

        

    }

    public List<Double[]> jacobiEvaluate(double[][] matrix, Double[] guess, List<Double[]> xyz){
        if(xyz.size() == maxIteration + 1){
            System.out.println("Max iterations reached. Cannot proceed.");
            return xyz;
        }
        Double nextGuess[] = new Double[3];
        nextGuess[0] = (-matrix[0][1] * guess[1] + -matrix[0][2] * guess[2] + matrix[0][3]) / matrix[0][0];
        nextGuess[1] = (-matrix[1][0] * guess[0] + -matrix[1][2] * guess[2] + matrix[1][3]) / matrix[1][1];
        nextGuess[2] = (-matrix[2][0] * guess[0] + -matrix[2][1] * guess[1] + matrix[2][3]) / matrix[2][2];
        
        if(Math.abs(nextGuess[0] - guess[0]) < tolerance.doubleValue() && Math.abs(nextGuess[1] - guess[1]) < tolerance.doubleValue() && Math.abs(nextGuess[2] - guess[2]) < tolerance.doubleValue()){
            nextGuess[0] = new BigDecimal(nextGuess[0]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            nextGuess[1] = new BigDecimal(nextGuess[1]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            nextGuess[2] = new BigDecimal(nextGuess[2]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            xyz.add(nextGuess);
            return xyz;
        } else {
            nextGuess[0] = new BigDecimal(nextGuess[0]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            nextGuess[1] = new BigDecimal(nextGuess[1]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            nextGuess[2] = new BigDecimal(nextGuess[2]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
            xyz.add(nextGuess);
            return jacobiEvaluate(matrix, nextGuess, xyz);
        }
    }

    public List<Double[]> gaussSeidel(double[][] matrix, Double[] guess, List<Double[]> xyz){
       
        
        //still cant wrap my head around this shit man
        for (int i = 0; i < matrix.length; i++) {
            int maxRow = i;
            for (int j = i + 1; j < matrix.length; j++) {
                if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
                    maxRow = j;
                }
            }

            // Swap if a more dominant row is found
            if (maxRow != i) {
                double[] temp = matrix[i];
                matrix[i] = matrix[maxRow];
                matrix[maxRow] = temp;
            }
        }
        
        
        
        
        return gaussSeidelEvaluate(matrix, guess, xyz);

        

    }

    public List<Double[]> gaussSeidelEvaluate(double[][] matrix, Double[] guess, List<Double[]> xyz){
        if(xyz.size() == maxIteration){
            System.out.println("Max iterations reached. Cannot proceed.");
            return xyz;
        }
        Double nextGuess[] = new Double[3];
        nextGuess[0] = (-matrix[0][1] * guess[1] + -matrix[0][2] * guess[2] + matrix[0][3]) / matrix[0][0];
        nextGuess[1] = (-matrix[1][0] * nextGuess[0] + -matrix[1][2] * guess[2] + matrix[1][3]) / matrix[1][1];
        nextGuess[2] = (-matrix[2][0] * nextGuess[0] + -matrix[2][1] * nextGuess[1] + matrix[2][3]) / matrix[2][2];
        nextGuess[0] = new BigDecimal(nextGuess[0]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        nextGuess[1] = new BigDecimal(nextGuess[1]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        nextGuess[2] = new BigDecimal(nextGuess[2]).divide(tolerance, 0, RoundingMode.HALF_UP).multiply(tolerance).doubleValue();
        System.out.println(Arrays.toString(nextGuess));
        if(Math.abs(nextGuess[0] - guess[0]) < tolerance.doubleValue() && Math.abs(nextGuess[1] - guess[1]) < tolerance.doubleValue() && Math.abs(nextGuess[2] - guess[2]) < tolerance.doubleValue()){
            xyz.add(nextGuess);
            return xyz;
        } else {
            xyz.add(nextGuess);
            return gaussSeidelEvaluate(matrix, nextGuess, xyz);
        }
    }

    
    public Expression parseEquation(String equation){
        String[] parsedEquation = new String[2];
        // Clean the input string
        equation = equation.replaceAll("[^\\x00-\\x7F]", ""); // Remove non-ASCII characters
        equation = equation.replaceAll("\\s+", " ").trim(); // Normalize whitespace
        if(equation.contains("=")){
            parsedEquation[0] = equation.substring(0, equation.indexOf('=')).trim();
            parsedEquation[1] = equation.substring(equation.indexOf('=') + 1, equation.length()).trim();
            return new ExpressionBuilder(parsedEquation[0]).variable("x").build();
        }
        return new ExpressionBuilder(equation).variable("x").build();
    }
    
    // need a error handling if the input is not 3 equations.
    public double[][] parseMatrixEquation(String equation){
        double[][] matrix = new double[3][4];
        String[] equations = equation.split("\\n");
        for(int i = 0; i < equations.length; i++){
            String[] parsedEquation = new String[2];
            equations[i].indexOf('=');
            parsedEquation[0] = equations[i].substring(0, equations[i].indexOf('=')).trim();
            parsedEquation[1] = equations[i].substring(equations[i].indexOf('=') + 1, equations[i].length()).trim();
            
            matrix[i][0] = new ExpressionBuilder(parsedEquation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 1)
                                .setVariable("y", 0)
                                .setVariable("z", 0)
                                .evaluate();
            matrix[i][1] = new ExpressionBuilder(parsedEquation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 0)
                                .setVariable("y", 1)
                                .setVariable("z", 0)
                                .evaluate();
            matrix[i][2] = new ExpressionBuilder(parsedEquation[0])
                                .variables("x", "y", "z")
                                .build()
                                .setVariable("x", 0)
                                .setVariable("y", 0)
                                .setVariable("z", 1)
                                .evaluate();
            matrix[i][3] = Double.parseDouble(parsedEquation[1]);                  
        }
        return matrix;

    }
    
    
}
